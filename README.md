# Python道場（1日1問の筋トレ修行）

Pythonの文法を手に馴染ませるため、1日1問ずつ問題に取り組んでいます。

毎日の問題は ChatGPT に出題してもらい、基本的な書き方の練習と、
GitHub を使った add / commit / push の習慣化も目的としています。

---

## 🥋 修行の目的

- Pythonの基本文法を自然に書けるようにする
- 1日10〜15分で継続できる習慣を作る
- Git操作（add / commit / push）を毎日の流れにする

---

## 📅 修行ログ

<details>
<summary>📁 2025年4月の修行</summary>

- `2025-04-06.py`：
  - リストから偶数を抽出する関数（内包表記あり）

- `2025-04-07.py`：
  - 文字列から母音だけを抽出する関数（`for`文 & `list comprehension`）

- `2025-04-07-2.py`：
  - 文字列から母音が出現する**インデックス**のみ抽出（`enumerate()` 入門＆応用）

- `2025-04-08.py`：
  - 偶数のみを2倍して返す関数（`for`文＋内包表記の使い分け）

- `2025-04-08-2.py`：
  - 文字列から小文字アルファベットのみ抽出（正規表現での処理）

- `2025-04-09.py`：
  - 英数字のみを抽出する関数（`.isalnum()`＋`.isascii()` を併用して漢字や記号を除外）

- `2025-04-10.py`：
  - 文字列から数字だけを抽出する関数（`.isdigit()`＋`.isascii()`で全角と半角を制御）

- `2025-04-10-2.py`：
  - テキストファイルから「数字だけの行」を抽出する処理（`with open()` によるファイル読み取り・`strip()`活用）

- `2025-04-10-3.py`：
  - テキストファイルの内容を逆順にして別ファイルに書き出す（`readlines()`＋`.reverse()`＋`write()` の基本型）

- `2025-04-11.py`：
  - 今日の日付とメッセージを "input.txt" に追記する関数（`datetime.date.today()`＋`write()`＋追記モード `"a"` を活用）

- `2025-04-12.py`：
  - テキストファイル内から特定のキーワードを含む行だけを抽出する関数（`in` 演算子＋`.lower()`で大文字・小文字を無視した検索を実装）

- `2025-04-13.py`：
  - テキストファイルの内容を「行番号付き」で表示する関数（`enumerate()` の `start` パラメータを活用し、表示順を1から開始）

- `2025-04-14.py`：
  - "input.txt" から数字だけの行を抽出し、"output.txt" に書き出す関数（`isdigit()` を使った条件フィルタ＋リスト操作＋ファイル出力の基本型を確認）

- `2025-04-15.py`：
  - CSVファイルの各行を行番号付きで表示（`csv.reader()`＋`enumerate(start=1)` による基本の読み取り）

- `2025-04-15-2.py`：
  - CSVファイルから2列目のデータだけを抽出して表示（インデックスアクセス `[1]` による列指定処理）

- `2025/0416-1/2025-04-16-1.py`：
  - CSVファイルから2列目が "Python" の行だけを抽出し、リストとして出力

- `2025/0416-2/2025-04-16-2.py`：
  - 抽出した行を新たなCSVファイルに書き出し（`csv.writer()`＋`writerows()`）

- `2025/0416-3/2025-04-16-3.py`：
  - CSVファイルの全行を行番号付きで `log.txt` に記録（`enumerate(..., start=1)`）
  - ※ 実行環境によるカレントディレクトリの違いにより、`__file__` を使ったパス構成方法を習得
  - ※ `os.path.dirname(__file__)` を重ねて階層をさかのぼる応用パターンも確認

- `2025/0418/2025-04-18-1.py`：
  - 2列目に "Python" を含む行のみ抽出し、`log.txt` に出力（部分一致 + 大文字小文字無視）
  - 内包表記による一行出力表現も試行
  - `",".join(row)` vs `str(row)` の出力フォーマットの違いを確認

- `2025/0418/2025-04-18-2.py`：
  - "Python" を含む行だけを `filtered.csv` に出力し、同時に件数を `log.txt` に記録
  - 処理ステップを明確に分けて記述（読み込み → 抽出 → 書き出し → ログ）
  - 行数カウント処理（`match_rows_count`）と、内包表記による `len()` 利用パターンの違いを体感
  - 書き方の構造改善（フィルタ結果のリスト化 → 使い回し可能な形）について考察

- `2025/0419/2025-04-19.py`：
  - `file1.csv` と `file2.csv` を読み込み、内容を1つのファイルに統合（`merged.csv`）
  - `csv.reader()` でリスト化した2ファイルの内容を `list_f1 + list_f2` で結合
  - `csv.writer().writerows()` による一括書き出し構成を採用
  - 複数ファイルの読み→統合→書き出しの流れを正確に整理・実装
  - 🌱 修行中に遭遇した「`writerow` を `writerrow` と書いてしまう」タイプミスを自己発見・自己修正
  - この気づきから `writerow()` vs `writerows()` の違いと用途も再確認
  - 打鍵ミスに気づく観察力とリカバリー力の重要性を実感

- `2025/0420/2025-04-20.py`：
  - `"sample.csv"` から「2列目に 'Python' を含む行」だけを抽出し、"filtered.csv" に出力
  - 書き込みモード（"追記" or "上書き"）を `input()` で選択可能にするインタラクション実装
  - `"python" in row[1].lower()` による部分一致＆大小文字無視の柔軟なフィルタ判定
  - 書き込み方法や出力構成の見直しを通して、より実践的なフロー設計に対する理解が深まる
  - 入力バリデーション（`y/n`判定）やエラー防止のフロー順設計にも気づきあり

- `2025/0421/task20250421-2.py`：
  - `sample.csv` の中から「2列目に 'Python' を含む行」を抽出（大文字小文字無視）
  - 抽出された行を `filtered.csv` に書き出し（`csv.writer().writerows()` を使用）
  - 抽出件数を `log.txt` に "抽出件数：X件" という形式で記録
  - 書き出し形式や出力数の確認を通じて、ファイル構造の正確さを意識した構え
  - ☑ 実行ファイル・入力CSV・出力ログすべてが整っており、実務に耐える一連の流れを自力で完成
  - ☑ コードの整形・責務の分離・エラーへの気づき・自己修正も含め、道場流“型”の真髄を実践

- `2025/0422/task0422.py`：
  - `sample.csv` の中から「1列目に 'A' を含む行」を抽出し、`filtered.csv` に書き出し
  - 大文字小文字を区別せず部分一致でのフィルタ処理（`"A" in row[0].upper()`）
  - `writer.writerows()` によるCSV形式での出力処理を採用

- `2025/0422/task0422-2.py`：
  - `sample.csv` の中から「3列目が5より大きい」行のみ抽出し、`filtered.csv` に書き出し
  - `int(row[2]) > 5` での数値判定＋`try-except` による変換失敗時の安全対策
  - 正常終了時の `print("filter completed!")` を導入し、処理完了の明示も実施
- `2025/0423/task0423.py`：
  - `sample.csv` の中から「2列目に 'Java' を含まない行」だけを抽出し、`filtered.csv` に書き出し
  - 判定は `row[1].lower()` を使い小文字で統一、部分一致の否定に `not in` を使用
  - 命名の見直し (`filtered_path` → `filtered_csv_path`) によって構造的な可読性も向上

- `2025/0423/task0423-2.py`：
  - `sample.csv` の中から「3列目が整数でかつ偶数」である行のみ抽出して書き出し
  - `int()` による数値化に対して `try-except` を組み込み、文字列や小数をエラーとして回避
  - `isinstance(num, int)` による型の安全確認も導入し、より堅牢な条件構文を構築
  - `print(e)` で例外内容も明示し、ログ出力的にも活用可能な仕上がりに

- `2025/0424/task0424.py`：
  - `file1.csv` と `file2.csv` の中から、「2列目が 'Python'」の行だけを抽出し、`filtered.csv` に書き出す処理
  - 大文字小文字を無視して一致判定（`row[1].lower() == "python"`）
  - 2ファイルを `for path in (...)` でスマートにループ処理し、1パスで条件抽出
  - 書き出しは `writer.writerows()` でまとめて出力、構造も出力も明確に仕上げた

- `2025/0425/task0425.py`：
  - `file1.csv` と `file2.csv` を結合し、3列目（インデックス2）の数値を昇順（小さい順）にソート
  - `key=lambda r: int(r[2])` を使ってlambda関数でソート基準を指定
  - `writer.writerows()` による一括出力
  - sortの基本型（昇順）を習得

- `2025/0425/task0425-2.py`：
  - 同じく `file1.csv` と `file2.csv` を結合し、3列目の数値を今度は降順（大きい順）にソート
  - `reverse=True` を付けて並び順をコントロール
  - lambda式とsortの組み合わせにさらに慣れ、自在に並び順を操れるレベルに到達
  - sort＋lambdaの動作原理（キー生成→比較）も深く理解- `2025/0426/task0426.py`：
  - `file1.csv` と `file2.csv` を結合し、
  - 2列目に "Python" を含む行のみ抽出、
  - さらに3列目（数値）を降順で並び替え、
  - `sorted_python.csv` に出力！
  - sort()＋lambda応用と、フィルタリング処理を同時に組み合わせる実戦型！

- `2025/0426/task0426-2.py`：
  - `file1.csv` と `file2.csv` をそれぞれ読み込み、
  - 2列目に "Python" を含む行だけフィルタリング、
  - 抽出行を `extend()` でまとめ上げ、
  - `filtered_python.csv` に出力！
  - 「ファイルごとにフィルタ → まとめて一括出力」という実践型の流れを完全習得！- `2025/0427/task0427.py`：
  - `file1.csv` と `file2.csv` を結合し、
  - 2列目に "Python" を含む行だけを抽出、
  - 3列目（数値）を降順、さらに同値の場合は1列目（文字列）を昇順に並び替え！
  - sort＋lambda＋タプル複合キーによる並び替えロジックを完全実装！
  - 「数値は -int() で反転」「文字列はそのまま昇順」という並び替え戦略をマスター！！
- `2025/0428/task0428.py`：
  - file1.csv / file2.csv を結合し、2列目に 'Python' を含む行を抽出
  - 3列目（数値）を降順、同じ値なら1列目（文字列）を降順にソート
  - lambda式による複合キーソートの型を習得
- `2025/0428/task0428-2.py`：
  - file1.csv / file2.csv を結合し、2列目に 'Python' を含み、3列目が50以上の行を抽出
  - 3列目を降順、1列目を昇順に並び替え
  - 数値比較と文字列の複合キー構成を正確に記述
- `2025/0429/task0429.py`：
  - file1.csv / file2.csv を結合し、2列目に 'Python' を含み、3列目が50以上の行を抽出
  - 3列目（数値）を降順、1列目（文字列）を昇順に並び替え
  - lambda式でのキー指定に慣れ、複合ソートを自在に操れるように
- `2025/0430/task0430.py`：
  - sorted()とlist.sort()の違い、破壊的メソッドか否かを整理
  - lambda式と比較キーの関係、降順ソートの仕組み（-int等）を実験
  - 複雑なキー（数値＋文字列）の扱いを理解し、sortに強くなる
</details>
<details>
<summary>📁 2025年5月の修行</summary>

- `2025/0501/task0501.py`：
  - file1.csv / file2.csv を結合し、2列目が 'Python' の行のみを抽出
  - 完全一致の重複行を除去（先に出た1件を残す）
  - set + list で順序を保持した重複除去を実装

- `2025/0502/task0502.py`：
  - `file1.csv` と `file2.csv` を読み込み、2列目に "Python" を含む行の3列目（数値）を合計
  - 該当行の抽出 → 数値化（`int()`）→ 合計（`sum()`）のシンプルな構成
  - 内包表記で一気通貫に処理を記述し、読みやすさと効率性を両立

- `2025/0503/task0503.py`：
  - `file1.csv` と `file2.csv` を読み込み、**1列目が "A" で始まる**行だけを抽出し、`filtered.csv` に書き出し
  - `startswith()` の基本使用法と、`.strip()` での前処理の重要性を確認
  - 条件付きフィルタの実践的パターンとして応用力を高めた

- `2025/0503/task0503-2.py`：
  - ヘッダー付きCSVを `csv.DictReader()` で読み込み、辞書形式で表示する処理を実装
  - 読み込み時にも `newline=''` を指定する方が安全であることを再確認- `2025/0504/task0504.py`：
  - `csv.DictReader` を使い、列名 (`row['language']`) を指定して条件フィルタリングを実行
  - `.lower()` を用いて大文字小文字を区別しない判定を実装- `2025/0505/task0505.py`：
  - `csv.DictReader` を用いてCSVを辞書として読み込み
  - 特定列 (`level`) の値でフィルタし、別の列 (`name`) の値を抽出・表示
  - 条件比較の厳密性 (`==` vs `in`)、Python/JSのアクセス記法の違いについて考察
- `2025/0505/task0505-2.py`：
  - `csv.DictWriter` を導入し、辞書データから特定の列 (`name`, `email`) だけを選んで新しいCSVファイル (`experts.csv`) に書き出し
  - `fieldnames` の指定、`writeheader()`、`writerow()` の正しい使い方を習得・修正
  - 要件定義（ファイル名、列名指定）を正確に満たすことの重要性を再確認

- `2025/0505-3/0505-3task.py`：
  - `users.csv` を読み込み、「Expert」かどうかで `is_expert` カラムを付加
  - `DictReader` で辞書形式に読み込み、各行に `row["is_expert"] = "yes" or "no"` を追加
  - 加工後の辞書リストを `DictWriter` で `"users_loaded.csv"` に書き出し
  - ヘッダー行を手動指定し、`writeheader()` を使って整ったCSV構造に

</details>

---

## 🧗 現在の修行レベル

- **開始日**：2025年4月6日
- **現在の難易度**：★★★★（DictWriter応用＋値の加工フェーズ）
  - 読み込んだCSVデータの加工（列追加）処理を習得
  - `DictReader` → 条件判定 → 加工 → `DictWriter` の一連の流れが自然に書ける
  - フィールド名の明示と整った出力形式を意識できるように
---

引き続き精進！
※この履歴はGPT兄さんが作成しています
